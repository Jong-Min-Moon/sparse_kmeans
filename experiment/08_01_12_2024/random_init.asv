function cluster_est_now = random_init(x, sigma, K, n_init, rounding)
n = size(x,1);
p = size(x,2);
pd = makedist('Multinomial', 'Probabilities', repelem(1/K, K))
cluster_init = pd.random(n_init, )
for init_num = 1:n_init
    cluster_init_now = estimate_cluster(Z_now, rounding, n, cluster_true);
end



   

cluster_acc_before_thres = max( mean(cluster_true ==  cluster_est_now), mean(cluster_true == -cluster_est_now));
fprintf("\np = %i, acc_init: %f \n", p, cluster_acc_before_thres);
n_g1_now = sum(cluster_est_now == 1);
n_g2_now = sum(cluster_est_now ==-1); 
fprintf("n_{G1}_init = %i, n_{G1}_init = %i\n", n_g1_now, n_g2_now )
thres = sqrt(2 * log(p) );
fprintf("threshold: (%f)\n", thres)
% iterate
for iter = 1:n_iter
    fprintf("\n%i th thresholding\n\n", iter)
    % 1. estimate cluster means


    if max(n_g1_now, n_g2_now) ==n
        fprintf("all observations are clustered into one group")
        cluster_acc = 0.5;
        return 
    end

            
    x_now_g1 = x((cluster_est_now ==  1), :); 
    x_now_g2 = x((cluster_est_now == -1), :);
        
    x_bar_g1 = mean(x_now_g1, 1);  
    x_bar_g2 = mean(x_now_g2, 1);
            
    % 2. threshold the data matrix

       
    abs_diff = abs(x_bar_g1 - x_bar_g2) * sqrt( n_g1_now*n_g2_now/n ) / sigma;
    abs_diff_sort = -sort(-abs_diff);
    top_10 = abs_diff_sort(1:10);
    fprintf("normalized difference top 10 max: (%f) * sigma \n", top_10)

    thresholder_vec = abs_diff > thres;
    fprintf("%i entries survived \n\n",sum(thresholder_vec))
    find(thresholder_vec)
